{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentation de <lib-cmapper> Apprenez \u00e0 utiliser la librairie lib-cmapper pour cr\u00e9er des programmes optimales. Parcourez des tutoriels, des exemples de code, des bases, des informations de r\u00e9f\u00e9rence sur les structures de donn\u00e9es et plus encore.","title":"Home"},{"location":"#documentation-de-lib-cmapper","text":"Apprenez \u00e0 utiliser la librairie lib-cmapper pour cr\u00e9er des programmes optimales. Parcourez des tutoriels, des exemples de code, des bases, des informations de r\u00e9f\u00e9rence sur les structures de donn\u00e9es et plus encore.","title":"Documentation de &lt;lib-cmapper&gt;"},{"location":"about/","text":"","title":"About"},{"location":"Data_Structures/graph/graph_8c/","text":"Documentation Graphes #include <stdio.h> #include <stdlib.h> #include \"graph.h\" #include \"../queue/queue.h\" Definition du graphe int numVertices int* visited struct NODE** adj Documentation des attributs \u25c6 adj >> struct NODE** adj \u25c6 numVertices >> int numVertices \u25c6 visited >> int* visited Code Source #ifndef GRAPH_H_ #define GRAPH_H_ typedef struct NODE { int vertex; struct NODE* next; }Node; //struct node* createNode(int v); typedef struct GRAPH { int numVertices; int *visited; struct NODE** adj; }Graph; Node* createNode(int v); Graph* createGraph(int vertices); void addEdge(Graph* graph, int s, int d); void printGraph(Graph* graph); void free_graph(Graph* graph); void DFS(Graph* graph, int vertex); void BFS(Graph* graph, int startVertex); #endif Documentation des fonctions \u25c6 addEdge() >> void addEdge (Graph * g, int s, int d) \u25c6 BFS() >> void BFS (Graph * graph, int startVertex) \u25c6 createGraph() >> Graph * createGraph (int vertices) \u25c6 createNode() >> Node * createNode (int v) \u25c6 DFS() >> void DFS (Graph * graph, int vertex) \u25c6 free_graph() >> void free_graph (Graph * g) \u25c6 printGraph() >> void printGraph (Graph * g)","title":"Graphes"},{"location":"Data_Structures/graph/graph_8c/#documentation-graphes","text":"#include <stdio.h> #include <stdlib.h> #include \"graph.h\" #include \"../queue/queue.h\"","title":"Documentation Graphes"},{"location":"Data_Structures/graph/graph_8c/#definition-du-graphe","text":"int numVertices int* visited struct NODE** adj","title":"Definition du graphe"},{"location":"Data_Structures/graph/graph_8c/#documentation-des-attributs","text":"","title":"Documentation des attributs"},{"location":"Data_Structures/graph/graph_8c/#adj","text":">> struct NODE** adj","title":"\u25c6 adj"},{"location":"Data_Structures/graph/graph_8c/#numvertices","text":">> int numVertices","title":"\u25c6 numVertices"},{"location":"Data_Structures/graph/graph_8c/#visited","text":">> int* visited","title":"\u25c6 visited"},{"location":"Data_Structures/graph/graph_8c/#code-source","text":"#ifndef GRAPH_H_ #define GRAPH_H_ typedef struct NODE { int vertex; struct NODE* next; }Node; //struct node* createNode(int v); typedef struct GRAPH { int numVertices; int *visited; struct NODE** adj; }Graph; Node* createNode(int v); Graph* createGraph(int vertices); void addEdge(Graph* graph, int s, int d); void printGraph(Graph* graph); void free_graph(Graph* graph); void DFS(Graph* graph, int vertex); void BFS(Graph* graph, int startVertex); #endif","title":"Code Source"},{"location":"Data_Structures/graph/graph_8c/#documentation-des-fonctions","text":"","title":"Documentation des fonctions"},{"location":"Data_Structures/graph/graph_8c/#addedge","text":">> void addEdge (Graph * g, int s, int d)","title":"\u25c6 addEdge()"},{"location":"Data_Structures/graph/graph_8c/#bfs","text":">> void BFS (Graph * graph, int startVertex)","title":"\u25c6 BFS()"},{"location":"Data_Structures/graph/graph_8c/#creategraph","text":">> Graph * createGraph (int vertices)","title":"\u25c6 createGraph()"},{"location":"Data_Structures/graph/graph_8c/#createnode","text":">> Node * createNode (int v)","title":"\u25c6 createNode()"},{"location":"Data_Structures/graph/graph_8c/#dfs","text":">> void DFS (Graph * graph, int vertex)","title":"\u25c6 DFS()"},{"location":"Data_Structures/graph/graph_8c/#free_graph","text":">> void free_graph (Graph * g)","title":"\u25c6 free_graph()"},{"location":"Data_Structures/graph/graph_8c/#printgraph","text":">> void printGraph (Graph * g)","title":"\u25c6 printGraph()"},{"location":"Data_Structures/list/linked_list_8c/","text":"Documentation listes chain\u00e9es #include <stdlib.h> #include \"list.h\" Qu'est ce qu'une liste chain\u00e9e ? Une liste chain\u00e9e est une structure de donn\u00e9es compos\u00e9e de plusieurs \u00e9l\u00e9ments appel\u00e9s noeux cha\u00een\u00e9s entre eux. Chaque \u00e9l\u00e9ment (n\u0153ud) de la liste est fourni avec deux champs, appel\u00e9s liens, qui sont les r\u00e9f\u00e9rences au n\u0153ud pr\u00e9c\u00e9dent et suivant dans la s\u00e9quence de n\u0153uds. Cette structure permet l'insertion ou la suppression d'un n\u0153ud sans avoir \u00e0 d\u00e9placer les n\u0153uds adjacents, contrairement aux tableaux. list Struct Reference #include <linked_list.h> Definition de la liste chain\u00e9e struct list *next int data Documentation des attributs \u25c6 data >> int data \u25c6 next >> struct list * next Data Structures struct list Type Definitions typedef struct list List Code Source #ifndef _LIST_H_ #define _LIST_H_ #include <stdio.h> #include <stdlib.h> struct list { struct list *next; int data; }; // Initialize the sentinel of an empty list. void list_init(struct list *list); // Return true if the list is empty. // Otherwise, return false. // Do not forget that there is always a sentinel. // So the list is empty if the sentinel does not point to a next element. int list_is_empty(struct list *list); // Return the length of the list (sentinel excluded). size_t list_len(struct list *list); // Insert 'elm' in front of the list, that is just after the sentinel. // Note that 'elm' is already an existing element. // You just have to insert it. void list_push_front(struct list *list, struct list *elm); // Extract the first element (not the sentinel) of the list. // This operation removes the element from the list and returns it // (the caller is responsible for freeing it). // If the list is empty, the function returns NULL. struct list* list_pop_front(struct list *list); // Search for the first element that contains 'value' and return it // (without removing it from the list). // The function returns NULL if the value is not in the list. struct list* list_find(struct list *list, int value); // Return true if the list is sorted in increasing order. // Otherwise, return false. int list_is_sorted(struct list *list); // Insert 'elm' in the sorted list (keeping the list sorted). // Note that 'elm' is already an existing element. // You just have to insert it. void list_insert(struct list *list, struct list *elm); // Reverse the elements of the list (except for the sentinel). void list_rev(struct list *list); #endif Documentation des fonctions \u25c6 list_find() // Trouve un \u00e9l\u00e9ment dans la liste chain\u00e9e // Prend en param\u00e8tre un pointeur sur la liste et la valeur \u00e0 trouver // Retourne un pointeur sur l'\u00e9l\u00e9ment trouv\u00e9 ou NULL >> struct list* list_find (struct list * list, int value) \u25c6 list_init() // Initialise la liste chain\u00e9e // Prend en param\u00e8tre un pointeur sur la liste // Ne retourne rien >> void list_init (struct list * list) \u25c6 list_insert() // Ins\u00e9rer un \u00e9l\u00e9ment dans la liste // Prend en param\u00e8tre un pointeur sur la liste et un pointeur sur l'\u00e9l\u00e9ment \u00e0 ins\u00e9rer // Ne retourne rien >> void list_insert (struct list * list, struct list * elm) \u25c6 list_is_empty() // V\u00e9rifier si la liste est vide // Prend en param\u00e8tre un pointeur sur la liste // Retourne 1 si la liste est vide, 0 sinon >> int list_is_empty (struct list * list) \u25c6 list_is_sorted() // V\u00e9rifier si la liste est tri\u00e9e // Prend en param\u00e8tre un pointeur sur la liste // Retourne 1 si la liste est tri\u00e9e, 0 sinon >> int list_is_sorted (struct list * list) \u25c6 list_len() // Calculer la longueur de la liste // Prend en param\u00e8tre un pointeur sur la liste // Retourne la longueur de la liste >> size_t list_len (struct list * list) \u25c6 list_pop_front() // Supprimer un \u00e9l\u00e9ment au d\u00e9but de la liste // Prend en param\u00e8tre un pointeur sur la liste // Retourne un pointeur sur l'\u00e9l\u00e9ment supprim\u00e9 >> struct list* list_pop_front (struct list * list) \u25c6 list_push_front() // Ajouter un \u00e9l\u00e9ment au d\u00e9but de la liste // Prend en param\u00e8tre un pointeur sur la liste et un pointeur sur l'\u00e9l\u00e9ment \u00e0 ajouter // Ne retourne rien >> void list_push_front (struct list * list, struct list * elm) \u25c6 list_rev() // Inverser la liste // Prend en param\u00e8tre un pointeur sur la liste // Ne retourne rien >> void list_rev (struct list * list)","title":"Listes chain\u00e9es"},{"location":"Data_Structures/list/linked_list_8c/#documentation-listes-chainees","text":"#include <stdlib.h> #include \"list.h\"","title":"Documentation listes chain\u00e9es"},{"location":"Data_Structures/list/linked_list_8c/#quest-ce-quune-liste-chainee","text":"Une liste chain\u00e9e est une structure de donn\u00e9es compos\u00e9e de plusieurs \u00e9l\u00e9ments appel\u00e9s noeux cha\u00een\u00e9s entre eux. Chaque \u00e9l\u00e9ment (n\u0153ud) de la liste est fourni avec deux champs, appel\u00e9s liens, qui sont les r\u00e9f\u00e9rences au n\u0153ud pr\u00e9c\u00e9dent et suivant dans la s\u00e9quence de n\u0153uds. Cette structure permet l'insertion ou la suppression d'un n\u0153ud sans avoir \u00e0 d\u00e9placer les n\u0153uds adjacents, contrairement aux tableaux.","title":"Qu'est ce qu'une liste chain\u00e9e ?"},{"location":"Data_Structures/list/linked_list_8c/#list-struct-reference","text":"#include <linked_list.h>","title":"list Struct Reference"},{"location":"Data_Structures/list/linked_list_8c/#definition-de-la-liste-chainee","text":"struct list *next int data","title":"Definition de la liste chain\u00e9e"},{"location":"Data_Structures/list/linked_list_8c/#documentation-des-attributs","text":"","title":"Documentation des attributs"},{"location":"Data_Structures/list/linked_list_8c/#data","text":">> int data","title":"\u25c6 data"},{"location":"Data_Structures/list/linked_list_8c/#next","text":">> struct list * next","title":"\u25c6 next"},{"location":"Data_Structures/list/linked_list_8c/#data-structures","text":"struct list","title":"Data Structures"},{"location":"Data_Structures/list/linked_list_8c/#type-definitions","text":"typedef struct list List","title":"Type Definitions"},{"location":"Data_Structures/list/linked_list_8c/#code-source","text":"#ifndef _LIST_H_ #define _LIST_H_ #include <stdio.h> #include <stdlib.h> struct list { struct list *next; int data; }; // Initialize the sentinel of an empty list. void list_init(struct list *list); // Return true if the list is empty. // Otherwise, return false. // Do not forget that there is always a sentinel. // So the list is empty if the sentinel does not point to a next element. int list_is_empty(struct list *list); // Return the length of the list (sentinel excluded). size_t list_len(struct list *list); // Insert 'elm' in front of the list, that is just after the sentinel. // Note that 'elm' is already an existing element. // You just have to insert it. void list_push_front(struct list *list, struct list *elm); // Extract the first element (not the sentinel) of the list. // This operation removes the element from the list and returns it // (the caller is responsible for freeing it). // If the list is empty, the function returns NULL. struct list* list_pop_front(struct list *list); // Search for the first element that contains 'value' and return it // (without removing it from the list). // The function returns NULL if the value is not in the list. struct list* list_find(struct list *list, int value); // Return true if the list is sorted in increasing order. // Otherwise, return false. int list_is_sorted(struct list *list); // Insert 'elm' in the sorted list (keeping the list sorted). // Note that 'elm' is already an existing element. // You just have to insert it. void list_insert(struct list *list, struct list *elm); // Reverse the elements of the list (except for the sentinel). void list_rev(struct list *list); #endif","title":"Code Source"},{"location":"Data_Structures/list/linked_list_8c/#documentation-des-fonctions","text":"","title":"Documentation des fonctions"},{"location":"Data_Structures/list/linked_list_8c/#list_find","text":"// Trouve un \u00e9l\u00e9ment dans la liste chain\u00e9e // Prend en param\u00e8tre un pointeur sur la liste et la valeur \u00e0 trouver // Retourne un pointeur sur l'\u00e9l\u00e9ment trouv\u00e9 ou NULL >> struct list* list_find (struct list * list, int value)","title":"\u25c6 list_find()"},{"location":"Data_Structures/list/linked_list_8c/#list_init","text":"// Initialise la liste chain\u00e9e // Prend en param\u00e8tre un pointeur sur la liste // Ne retourne rien >> void list_init (struct list * list)","title":"\u25c6 list_init()"},{"location":"Data_Structures/list/linked_list_8c/#list_insert","text":"// Ins\u00e9rer un \u00e9l\u00e9ment dans la liste // Prend en param\u00e8tre un pointeur sur la liste et un pointeur sur l'\u00e9l\u00e9ment \u00e0 ins\u00e9rer // Ne retourne rien >> void list_insert (struct list * list, struct list * elm)","title":"\u25c6 list_insert()"},{"location":"Data_Structures/list/linked_list_8c/#list_is_empty","text":"// V\u00e9rifier si la liste est vide // Prend en param\u00e8tre un pointeur sur la liste // Retourne 1 si la liste est vide, 0 sinon >> int list_is_empty (struct list * list)","title":"\u25c6 list_is_empty()"},{"location":"Data_Structures/list/linked_list_8c/#list_is_sorted","text":"// V\u00e9rifier si la liste est tri\u00e9e // Prend en param\u00e8tre un pointeur sur la liste // Retourne 1 si la liste est tri\u00e9e, 0 sinon >> int list_is_sorted (struct list * list)","title":"\u25c6 list_is_sorted()"},{"location":"Data_Structures/list/linked_list_8c/#list_len","text":"// Calculer la longueur de la liste // Prend en param\u00e8tre un pointeur sur la liste // Retourne la longueur de la liste >> size_t list_len (struct list * list)","title":"\u25c6 list_len()"},{"location":"Data_Structures/list/linked_list_8c/#list_pop_front","text":"// Supprimer un \u00e9l\u00e9ment au d\u00e9but de la liste // Prend en param\u00e8tre un pointeur sur la liste // Retourne un pointeur sur l'\u00e9l\u00e9ment supprim\u00e9 >> struct list* list_pop_front (struct list * list)","title":"\u25c6 list_pop_front()"},{"location":"Data_Structures/list/linked_list_8c/#list_push_front","text":"// Ajouter un \u00e9l\u00e9ment au d\u00e9but de la liste // Prend en param\u00e8tre un pointeur sur la liste et un pointeur sur l'\u00e9l\u00e9ment \u00e0 ajouter // Ne retourne rien >> void list_push_front (struct list * list, struct list * elm)","title":"\u25c6 list_push_front()"},{"location":"Data_Structures/list/linked_list_8c/#list_rev","text":"// Inverser la liste // Prend en param\u00e8tre un pointeur sur la liste // Ne retourne rien >> void list_rev (struct list * list)","title":"\u25c6 list_rev()"},{"location":"Data_Structures/node/node/","text":"Documentation Noeud Qu'est ce qu'un noeud ? En informatique, un noeud est repr\u00e9sent\u00e9 par une structure de donn\u00e9es contenant une ou plusieurs valeurs et un pointeur vers le noeud suivant dans la liste. #include <graph.h> Definition des noeuds int vertex struct NODE * next Documentation des attributs \u25c6 next >> struct NODE * next \u25c6 vertex >> int vertex","title":"Noeux"},{"location":"Data_Structures/node/node/#documentation-noeud","text":"","title":"Documentation Noeud"},{"location":"Data_Structures/node/node/#quest-ce-quun-noeud","text":"En informatique, un noeud est repr\u00e9sent\u00e9 par une structure de donn\u00e9es contenant une ou plusieurs valeurs et un pointeur vers le noeud suivant dans la liste. #include <graph.h>","title":"Qu'est ce qu'un noeud ?"},{"location":"Data_Structures/node/node/#definition-des-noeuds","text":"int vertex struct NODE * next","title":"Definition des noeuds"},{"location":"Data_Structures/node/node/#documentation-des-attributs","text":"","title":"Documentation des attributs"},{"location":"Data_Structures/node/node/#next","text":">> struct NODE * next","title":"\u25c6 next"},{"location":"Data_Structures/node/node/#vertex","text":">> int vertex","title":"\u25c6 vertex"},{"location":"Data_Structures/queue/queue_8c/","text":"Documentation Files #include <stdlib.h> #include <stdio.h> #include \"queue.h\" Qu'est ce qu'une file ? Une file est une structure de donn\u00e9es qui permet de stocker des \u00e9l\u00e9ments de fa\u00e7on ordonn\u00e9e. Les \u00e9l\u00e9ments sont ajout\u00e9s \u00e0 la fin de la file et retir\u00e9s au d\u00e9but de la file. On parle de structure de donn\u00e9es FIFO (First In First Out) ou PEPS (Premier Entr\u00e9 Premier Sorti). Definition de la file int items [SIZE] int front int rear Definition des attributs \u25c6 front >> int front \u25c6 items >> int items[SIZE] \u25c6 rear >> int rear Data Structures struct QUEUE Type Definitions typedef struct QUEUE Queue Code Source #ifndef QUEUE_H_ #define QUEUE_H_ #define SIZE 40 typedef struct QUEUE { int items[SIZE]; int front; int rear; }Queue; Queue* createQueue(); void enqueue(Queue* q, int); int dequeue(Queue* q); Queue* createFillQueue(int n); void display(Queue* q); int isEmpty(Queue* q); void printQueue(Queue* q); #endif Definition des fonctions \u25c6 createFillQueue() >> Queue* createFillQueue (int n) \u25c6 createQueue() >> Queue* createQueue () \u25c6 dequeue() >> int dequeue (Queue * q) \u25c6 enqueue() >> void enqueue (Queue * q, int value) \u25c6 isEmpty() >> int isEmpty (Queue * q) \u25c6 printQueue() >> void printQueue (Queue * q)","title":"Files"},{"location":"Data_Structures/queue/queue_8c/#documentation-files","text":"#include <stdlib.h> #include <stdio.h> #include \"queue.h\"","title":"Documentation Files"},{"location":"Data_Structures/queue/queue_8c/#quest-ce-quune-file","text":"Une file est une structure de donn\u00e9es qui permet de stocker des \u00e9l\u00e9ments de fa\u00e7on ordonn\u00e9e. Les \u00e9l\u00e9ments sont ajout\u00e9s \u00e0 la fin de la file et retir\u00e9s au d\u00e9but de la file. On parle de structure de donn\u00e9es FIFO (First In First Out) ou PEPS (Premier Entr\u00e9 Premier Sorti).","title":"Qu'est ce qu'une file ?"},{"location":"Data_Structures/queue/queue_8c/#definition-de-la-file","text":"int items [SIZE] int front int rear","title":"Definition de la file"},{"location":"Data_Structures/queue/queue_8c/#definition-des-attributs","text":"","title":"Definition des attributs"},{"location":"Data_Structures/queue/queue_8c/#front","text":">> int front","title":"\u25c6 front"},{"location":"Data_Structures/queue/queue_8c/#items","text":">> int items[SIZE]","title":"\u25c6 items"},{"location":"Data_Structures/queue/queue_8c/#rear","text":">> int rear","title":"\u25c6 rear"},{"location":"Data_Structures/queue/queue_8c/#data-structures","text":"struct QUEUE","title":"Data Structures"},{"location":"Data_Structures/queue/queue_8c/#type-definitions","text":"typedef struct QUEUE Queue","title":"Type Definitions"},{"location":"Data_Structures/queue/queue_8c/#code-source","text":"#ifndef QUEUE_H_ #define QUEUE_H_ #define SIZE 40 typedef struct QUEUE { int items[SIZE]; int front; int rear; }Queue; Queue* createQueue(); void enqueue(Queue* q, int); int dequeue(Queue* q); Queue* createFillQueue(int n); void display(Queue* q); int isEmpty(Queue* q); void printQueue(Queue* q); #endif","title":"Code Source"},{"location":"Data_Structures/queue/queue_8c/#definition-des-fonctions","text":"","title":"Definition des fonctions"},{"location":"Data_Structures/queue/queue_8c/#createfillqueue","text":">> Queue* createFillQueue (int n)","title":"\u25c6 createFillQueue()"},{"location":"Data_Structures/queue/queue_8c/#createqueue","text":">> Queue* createQueue ()","title":"\u25c6 createQueue()"},{"location":"Data_Structures/queue/queue_8c/#dequeue","text":">> int dequeue (Queue * q)","title":"\u25c6 dequeue()"},{"location":"Data_Structures/queue/queue_8c/#enqueue","text":">> void enqueue (Queue * q, int value)","title":"\u25c6 enqueue()"},{"location":"Data_Structures/queue/queue_8c/#isempty","text":">> int isEmpty (Queue * q)","title":"\u25c6 isEmpty()"},{"location":"Data_Structures/queue/queue_8c/#printqueue","text":">> void printQueue (Queue * q)","title":"\u25c6 printQueue()"},{"location":"Data_Structures/table/table_8c/","text":"Documentation Tableaux Qu'est ce qu'un tableau ? Un tableau repr\u00e9sente une collection d'\u00e9l\u00e9ments stock\u00e9s de mani\u00e8re contigu\u00eb dans la m\u00e9moire. L'objectif est de regrouper plusieurs \u00e9l\u00e9ments du m\u00eame type en un seul emplacement. Cette approche facilite le calcul de la position de chaque \u00e9l\u00e9ment en ajoutant un d\u00e9calage \u00e0 une valeur de r\u00e9f\u00e9rence, \u00e0 savoir l'emplacement en m\u00e9moire du premier \u00e9l\u00e9ment du tableau. Fonctions void array_random_fill (int array[], size_t len, int maxval) void array_sorted_fill (int array[], size_t len, int step) void array_reverse_sorted_fill (int array[], size_t len, int step) Documentation des fonctions \u25c6 array_random_fill() >> void array_random_fill (int array[], size_t len, int maxval) \u25c6 array_reverse_sorted_fill() >> void array_reverse_sorted_fill (int array[], size_t len, int step) \u25c6 array_sorted_fill() >> void array_sorted_fill (int array[], size_t len, int step)","title":"Tableaux"},{"location":"Data_Structures/table/table_8c/#documentation-tableaux","text":"","title":"Documentation Tableaux"},{"location":"Data_Structures/table/table_8c/#quest-ce-quun-tableau","text":"Un tableau repr\u00e9sente une collection d'\u00e9l\u00e9ments stock\u00e9s de mani\u00e8re contigu\u00eb dans la m\u00e9moire. L'objectif est de regrouper plusieurs \u00e9l\u00e9ments du m\u00eame type en un seul emplacement. Cette approche facilite le calcul de la position de chaque \u00e9l\u00e9ment en ajoutant un d\u00e9calage \u00e0 une valeur de r\u00e9f\u00e9rence, \u00e0 savoir l'emplacement en m\u00e9moire du premier \u00e9l\u00e9ment du tableau.","title":"Qu'est ce qu'un tableau ?"},{"location":"Data_Structures/table/table_8c/#fonctions","text":"void array_random_fill (int array[], size_t len, int maxval) void array_sorted_fill (int array[], size_t len, int step) void array_reverse_sorted_fill (int array[], size_t len, int step)","title":"Fonctions"},{"location":"Data_Structures/table/table_8c/#documentation-des-fonctions","text":"","title":"Documentation des fonctions"},{"location":"Data_Structures/table/table_8c/#array_random_fill","text":">> void array_random_fill (int array[], size_t len, int maxval)","title":"\u25c6 array_random_fill()"},{"location":"Data_Structures/table/table_8c/#array_reverse_sorted_fill","text":">> void array_reverse_sorted_fill (int array[], size_t len, int step)","title":"\u25c6 array_reverse_sorted_fill()"},{"location":"Data_Structures/table/table_8c/#array_sorted_fill","text":">> void array_sorted_fill (int array[], size_t len, int step)","title":"\u25c6 array_sorted_fill()"},{"location":"Data_Structures/tree/tree_8c/","text":"Documentation Arbres #include <tree.h> Qu'est ce qu'un arbre ? Un arbre est une structure de donn\u00e9es non lin\u00e9aire qui permet de stocker des \u00e9l\u00e9ments de fa\u00e7on hi\u00e9rarchique. Un arbre est compos\u00e9 d'un noeud racine et de sous-arbres. Chaque sous-arbre est lui-m\u00eame un arbre. Un arbre est compos\u00e9 de noeuds. Chaque noeud est compos\u00e9 d'une valeur et de deux pointeurs vers les sous-arbres gauche et droit. Definition d'un arbre int value struct tree * left struct tree * right Documentation des attributs \u25c6 left >> struct tree * left \u25c6 right >> struct tree * right \u25c6 value >> int value Data Structures struct tree Type Definitions typedef struct tree Tree Code Source #ifndef TREE_H_ #define TREE_H_ #include <stdlib.h> #include <stdio.h> struct tree { int value; struct tree* left; struct tree* right; }; struct tree* createTree(int data); size_t tree_size (struct tree* t); size_t max (size_t a, size_t b); size_t tree_height (struct tree* t); void free_tree (struct tree* t); struct tree* ajouter_noeud(struct tree* racine, int valeur); struct tree* supprimer_noeud(struct tree* racine, int valeur); void prefix_print(struct tree* t); void infix_print(struct tree* t); void prefix_print(struct tree* t); #endif Documentation des fonctions \u25c6 ajouter_noeud() >> struct tree* ajouter_noeud (struct tree * racine, int valeur) \u25c6 createTree() >> struct tree* createTree (int data) \u25c6 free_tree() >> void free_tree (struct tree * t) \u25c6 infix_print() >> void infix_print (struct tree * t) \u25c6 max() >> size_t max (size_t a, size_t b) \u25c6 minimum_dans_sous_arbre_droit() >> struct tree* minimum_dans_sous_arbre_droit (struct tree * racine) \u25c6 prefix_print() >> void prefix_print (struct tree * t) \u25c6 supprimer_noeud() >> struct tree* supprimer_noeud (struct tree * racine, int valeur) \u25c6 tree_height() >> size_t tree_height (struct tree * t) \u25c6 tree_size() >> size_t tree_size (struct tree * t)","title":"Arbres"},{"location":"Data_Structures/tree/tree_8c/#documentation-arbres","text":"#include <tree.h>","title":"Documentation Arbres"},{"location":"Data_Structures/tree/tree_8c/#quest-ce-quun-arbre","text":"Un arbre est une structure de donn\u00e9es non lin\u00e9aire qui permet de stocker des \u00e9l\u00e9ments de fa\u00e7on hi\u00e9rarchique. Un arbre est compos\u00e9 d'un noeud racine et de sous-arbres. Chaque sous-arbre est lui-m\u00eame un arbre. Un arbre est compos\u00e9 de noeuds. Chaque noeud est compos\u00e9 d'une valeur et de deux pointeurs vers les sous-arbres gauche et droit.","title":"Qu'est ce qu'un arbre ?"},{"location":"Data_Structures/tree/tree_8c/#definition-dun-arbre","text":"int value struct tree * left struct tree * right","title":"Definition d'un arbre"},{"location":"Data_Structures/tree/tree_8c/#documentation-des-attributs","text":"","title":"Documentation des attributs"},{"location":"Data_Structures/tree/tree_8c/#left","text":">> struct tree * left","title":"\u25c6 left"},{"location":"Data_Structures/tree/tree_8c/#right","text":">> struct tree * right","title":"\u25c6 right"},{"location":"Data_Structures/tree/tree_8c/#value","text":">> int value","title":"\u25c6 value"},{"location":"Data_Structures/tree/tree_8c/#data-structures","text":"struct tree","title":"Data Structures"},{"location":"Data_Structures/tree/tree_8c/#type-definitions","text":"typedef struct tree Tree","title":"Type Definitions"},{"location":"Data_Structures/tree/tree_8c/#code-source","text":"#ifndef TREE_H_ #define TREE_H_ #include <stdlib.h> #include <stdio.h> struct tree { int value; struct tree* left; struct tree* right; }; struct tree* createTree(int data); size_t tree_size (struct tree* t); size_t max (size_t a, size_t b); size_t tree_height (struct tree* t); void free_tree (struct tree* t); struct tree* ajouter_noeud(struct tree* racine, int valeur); struct tree* supprimer_noeud(struct tree* racine, int valeur); void prefix_print(struct tree* t); void infix_print(struct tree* t); void prefix_print(struct tree* t); #endif","title":"Code Source"},{"location":"Data_Structures/tree/tree_8c/#documentation-des-fonctions","text":"","title":"Documentation des fonctions"},{"location":"Data_Structures/tree/tree_8c/#ajouter_noeud","text":">> struct tree* ajouter_noeud (struct tree * racine, int valeur)","title":"\u25c6 ajouter_noeud()"},{"location":"Data_Structures/tree/tree_8c/#createtree","text":">> struct tree* createTree (int data)","title":"\u25c6 createTree()"},{"location":"Data_Structures/tree/tree_8c/#free_tree","text":">> void free_tree (struct tree * t)","title":"\u25c6 free_tree()"},{"location":"Data_Structures/tree/tree_8c/#infix_print","text":">> void infix_print (struct tree * t)","title":"\u25c6 infix_print()"},{"location":"Data_Structures/tree/tree_8c/#max","text":">> size_t max (size_t a, size_t b)","title":"\u25c6 max()"},{"location":"Data_Structures/tree/tree_8c/#minimum_dans_sous_arbre_droit","text":">> struct tree* minimum_dans_sous_arbre_droit (struct tree * racine)","title":"\u25c6 minimum_dans_sous_arbre_droit()"},{"location":"Data_Structures/tree/tree_8c/#prefix_print","text":">> void prefix_print (struct tree * t)","title":"\u25c6 prefix_print()"},{"location":"Data_Structures/tree/tree_8c/#supprimer_noeud","text":">> struct tree* supprimer_noeud (struct tree * racine, int valeur)","title":"\u25c6 supprimer_noeud()"},{"location":"Data_Structures/tree/tree_8c/#tree_height","text":">> size_t tree_height (struct tree * t)","title":"\u25c6 tree_height()"},{"location":"Data_Structures/tree/tree_8c/#tree_size","text":">> size_t tree_size (struct tree * t)","title":"\u25c6 tree_size()"}]}